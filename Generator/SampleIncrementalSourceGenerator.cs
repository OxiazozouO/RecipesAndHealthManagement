using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Generator;

/// <summary>
///     A sample source generator that creates a custom report based on class properties. The target class should be
///     annotated with the 'Generators.ReportAttribute' attribute.
///     When using the source code as a baseline, an incremental source generator is preferable because it reduces the
///     performance overhead.
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed class SampleIncrementalSourceGenerator : IIncrementalGenerator
{
    private const string Namespace = "Generators";
    private const string AttributeName = "AddOnlyUpdate";
    public const string Util = "OnlyUpdateUtil";
    public const string V = "1.0";

    private const string AttributeSourceCode =
        $$"""
          // <auto-generated/>
          namespace {{Namespace}}
          {
              [global::System.AttributeUsage(global::System.AttributeTargets.Field)]
              public class {{AttributeName}} : global::System.Attribute{}
          }
          """;


    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            $"{AttributeName}Attribute.g.cs",
            SourceText.From(AttributeSourceCode, Encoding.UTF8)));

        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(IsFieldWithAttribute, GetFieldWithAttribute)
            .Where(t => t != null)
            .Select((tuple, _) => tuple.Value)
            .Collect();

        context.RegisterSourceOutput(provider, GenerateCode);
    }

    private static bool IsFieldWithAttribute(SyntaxNode node, CancellationToken cancellationToken)
    {
        // 检查节点是否是字段声明并且包含特定的属性
        return node is FieldDeclarationSyntax fieldDeclaration &&
               fieldDeclaration.AttributeLists
                   .SelectMany(attrList => attrList.Attributes)
                   .Any(attr => attr.Name.ToString().Contains(AttributeName));
    }


    private static (FieldDeclarationSyntax, string, string)? GetFieldWithAttribute(GeneratorSyntaxContext context,
        CancellationToken _)
    {
        var fieldDeclaration = (FieldDeclarationSyntax)context.Node;
        var model = context.SemanticModel;

        foreach (var variable in fieldDeclaration.Declaration.Variables)
        {
            var fieldSymbol = model.GetDeclaredSymbol(variable) as IFieldSymbol;
            if (fieldSymbol == null) continue;

            var hasAttribute = fieldSymbol.GetAttributes()
                .Any(ad => ad.AttributeClass?.Name == AttributeName);

            if (hasAttribute)
            {
                var classDeclaration = fieldDeclaration.Parent as ClassDeclarationSyntax;
                var className = classDeclaration?.Identifier.Text;
                var nameSpace = fieldSymbol.ContainingType.ContainingNamespace.ToString();

                return (fieldDeclaration, className, nameSpace);
            }
        }

        return null;
    }

    /// <summary>
    /// </summary>
    /// <param name="context"></param>
    /// <param name="fields"></param>
    private static void GenerateCode(SourceProductionContext context,
        ImmutableArray<(FieldDeclarationSyntax, string, string)> fields)
    {
        foreach (var tuples in
                 fields.GroupBy(e => (e.Item3, e.Item2), v => v.Item1))
        {
            var (namespaceName, className) = tuples.Key;
            var properties = new List<(string, string)>();
            foreach (var fieldDeclaration in tuples)
                // 提取字段信息
                properties.AddRange(fieldDeclaration.Declaration.Variables
                    .Select(variable => (
                        FirstCharToUpper(variable.Identifier.Text),
                        fieldDeclaration.Declaration.Type.ToString()
                    )));

            if (properties.Count > 0)
            {
                var code = GenerateModel(namespaceName, className, properties);
                context.AddSource($"{className}.onlyUpdate.g.cs", SourceText.From(code, Encoding.UTF8));
            }
        }
    }

    /// <summary>
    /// </summary>
    /// <param name="input"></param>
    /// <returns></returns>
    public static string FirstCharToUpper(string input)
    {
        if (string.IsNullOrEmpty(input))
            return input;
        if (input.Length == 1)
            return char.ToUpper(input[0]).ToString();
        return char.ToUpper(input[0]) + input.Substring(1);
    }

    /// <summary>
    ///     生成包含属性的类模型的源代码。
    /// </summary>
    /// <param name="namespace">命名空间</param>
    /// <param name="className">类名</param>
    /// <param name="properties">属性列表</param>
    /// <returns>生成的类模型的源代码</returns>
    public static string GenerateModel(string @namespace, string className, List<(string Name, string Type)> properties)
    {
        var code = new StringBuilder();

        // 添加类声明的起始部分
        code.Append(
            $$"""
              // <auto-generated/>
              #pragma warning disable
              #nullable enable
              namespace {{@namespace}}
              {
                  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("{{Util}}","{{V}}")]
                  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
                  public partial class {{className}}
                  {

              """
        );

        // 为每个属性添加代码
        foreach (var property in properties)
            code.Append(
                $$"""
                          /// <inheritdoc cref="{{property.Name}}"/>
                          [global::System.CodeDom.Compiler.GeneratedCodeAttribute("{{Util}}","{{V}}")]
                          [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
                          public {{property.Type}} OnlyUpdate{{property.Name}}
                          {
                              set => OnlyUpdate(t => {{property.Name}} = t, value, nameof({{property.Name}}));
                          }

                  """
            );

        // 添加 OnlyUpdate 方法
        code.Append(
            $$"""
                      [global::System.CodeDom.Compiler.GeneratedCodeAttribute("{{Util}}","{{V}}")]
                      [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
                      private void OnlyUpdate<T>(global::System.Action<T> setter, T value, string caller)
                      {
                          OnlyUpdateFlag[caller]++;
                          setter(value);
                          OnlyUpdateFlag[caller]--;
                      }
                      [global::System.CodeDom.Compiler.GeneratedCodeAttribute("{{Util}}","{{V}}")]
                      [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
                      public bool IsOnlyUpdate(string caller)
                      {
                          return OnlyUpdateFlag.TryGetValue(caller, out var v) && v > 0;
                      }

              """
        );

        // 添加 OnlyUpdateFlag 字典
        code.Append(
            """
                    private readonly global::System.Collections.Generic.Dictionary<string, int> OnlyUpdateFlag = new global::System.Collections.Generic.Dictionary<string, int>()
                    {

            """);

        // 为每个属性添加字典项
        foreach (var property in properties) code.AppendLine($"            [nameof({property.Name})] = 0,");

        // 结束类声明
        code.Append("        };\n    }\n}\n");
        return code.ToString();
    }
}